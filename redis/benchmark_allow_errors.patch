diff -ur redis-6.2.12/src/redis-benchmark.c redis-6.2.12-patched/src/redis-benchmark.c
--- redis-6.2.12/src/redis-benchmark.c	2023-04-17 05:54:26.000000000 -0700
+++ redis-6.2.12-patched/src/redis-benchmark.c	2023-10-11 13:05:23.254248696 -0700
@@ -91,6 +91,7 @@
     redisAtomic int requests_issued;
     redisAtomic int requests_finished;
     redisAtomic int previous_requests_finished;
+    redisAtomic int requests_failed;
     int last_printed_bytes;
     long long previous_tick;
     int keysize;
@@ -127,6 +128,7 @@
     int enable_tracking;
     pthread_mutex_t liveclients_mutex;
     pthread_mutex_t is_updating_slots_mutex;
+    int connect_retries;
 } config;
 
 typedef struct _client {
@@ -473,7 +475,7 @@
     }
 }
 
-static void clientDone(client c) {
+static void clientDone(client c, bool reconnect) {
     int requests_finished = 0;
     atomicGet(config.requests_finished, requests_finished);
     if (requests_finished >= config.requests) {
@@ -481,7 +483,7 @@
         if (!config.num_threads && config.el) aeStop(config.el);
         return;
     }
-    if (config.keepalive) {
+    if (config.keepalive && !reconnect) {
         resetClient(c);
     } else {
         if (config.num_threads) pthread_mutex_lock(&(config.liveclients_mutex));
@@ -494,6 +496,12 @@
     }
 }
 
+static void handleReadFailure(client c) {
+    atomicIncr(config.requests_failed, 1);
+    clientDone(c, true);
+    return;
+}
+
 static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     client c = privdata;
     void *reply = NULL;
@@ -507,102 +515,112 @@
     if (c->latency < 0) c->latency = ustime()-(c->start);
 
     if (redisBufferRead(c->context) != REDIS_OK) {
-        fprintf(stderr,"Error: %s\n",c->context->errstr);
-        exit(1);
-    } else {
-        while(c->pending) {
-            if (redisGetReply(c->context,&reply) != REDIS_OK) {
+        if (!config.quiet) {
+            fprintf(stderr, "Error: %s\n",c->context->errstr);
+        }
+        handleReadFailure(c);
+        return;
+    }
+
+    while(c->pending) {
+
+        if (redisGetReply(c->context,&reply) != REDIS_OK) {
+            if (!config.quiet) {
                 fprintf(stderr,"Error: %s\n",c->context->errstr);
-                exit(1);
             }
-            if (reply != NULL) {
-                if (reply == (void*)REDIS_REPLY_ERROR) {
-                    fprintf(stderr,"Unexpected error reply, exiting...\n");
-                    exit(1);
-                }
-                redisReply *r = reply;
-                if (r->type == REDIS_REPLY_ERROR) {
-                    /* Try to update slots configuration if reply error is
-                    * MOVED/ASK/CLUSTERDOWN and the key(s) used by the command
-                    * contain(s) the slot hash tag.
-                    * If the error is not topology-update related then we
-                    * immediately exit to avoid false results. */
-                    if (c->cluster_node && c->staglen) {
-                        int fetch_slots = 0, do_wait = 0;
-                        if (!strncmp(r->str,"MOVED",5) || !strncmp(r->str,"ASK",3))
-                            fetch_slots = 1;
-                        else if (!strncmp(r->str,"CLUSTERDOWN",11)) {
-                            /* Usually the cluster is able to recover itself after
-                            * a CLUSTERDOWN error, so try to sleep one second
-                            * before requesting the new configuration. */
-                            fetch_slots = 1;
-                            do_wait = 1;
-                            printf("Error from server %s:%d: %s.\n",
-                                   c->cluster_node->ip,
-                                   c->cluster_node->port,
-                                   r->str);
-                        }
-                        if (do_wait) sleep(1);
-                        if (fetch_slots && !fetchClusterSlotsConfiguration(c))
-                            exit(1);
-                    } else {
-                        if (c->cluster_node) {
-                            printf("Error from server %s:%d: %s\n",
+            handleReadFailure(c);
+            return;
+        }
+
+        if (reply != NULL) {
+            if (reply == (void*)REDIS_REPLY_ERROR) {
+                fprintf(stderr,"Unexpected error reply, exiting...\n");
+                handleReadFailure(c);
+                return;
+            }
+            redisReply *r = reply;
+            if (r->type == REDIS_REPLY_ERROR) {
+                /* Try to update slots configuration if reply error is
+                * MOVED/ASK/CLUSTERDOWN and the key(s) used by the command
+                * contain(s) the slot hash tag.
+                * If the error is not topology-update related then we
+                * immediately exit to avoid false results. */
+                if (c->cluster_node && c->staglen) {
+                    int fetch_slots = 0, do_wait = 0;
+                    if (!strncmp(r->str,"MOVED",5) || !strncmp(r->str,"ASK",3))
+                        fetch_slots = 1;
+                    else if (!strncmp(r->str,"CLUSTERDOWN",11)) {
+                        /* Usually the cluster is able to recover itself after
+                        * a CLUSTERDOWN error, so try to sleep one second
+                        * before requesting the new configuration. */
+                        fetch_slots = 1;
+                        do_wait = 1;
+                        printf("Error from server %s:%d: %s.\n",
                                 c->cluster_node->ip,
                                 c->cluster_node->port,
                                 r->str);
-                        } else printf("Error from server: %s\n", r->str);
-                        exit(1);
                     }
+                    if (do_wait) sleep(1);
+                    if (fetch_slots && !fetchClusterSlotsConfiguration(c))
+                        exit(1);
+                } else {
+                    if (c->cluster_node) {
+                        printf("Error from server %s:%d: %s\n",
+                            c->cluster_node->ip,
+                            c->cluster_node->port,
+                            r->str);
+                    } else printf("Error from server: %s\n", r->str);
+                    handleReadFailure(c);
+                    return;
                 }
+            }
 
-                freeReplyObject(reply);
-                /* This is an OK for prefix commands such as auth and select.*/
-                if (c->prefix_pending > 0) {
-                    c->prefix_pending--;
-                    c->pending--;
-                    /* Discard prefix commands on first response.*/
-                    if (c->prefixlen > 0) {
-                        size_t j;
-                        sdsrange(c->obuf, c->prefixlen, -1);
-                        /* We also need to fix the pointers to the strings
-                        * we need to randomize. */
-                        for (j = 0; j < c->randlen; j++)
-                            c->randptr[j] -= c->prefixlen;
-                        /* Fix the pointers to the slot hash tags */
-                        for (j = 0; j < c->staglen; j++)
-                            c->stagptr[j] -= c->prefixlen;
-                        c->prefixlen = 0;
-                    }
-                    continue;
-                }
-                int requests_finished = 0;
-                atomicGetIncr(config.requests_finished, requests_finished, 1);
-                if (requests_finished < config.requests){
-                        if (config.num_threads == 0) {
-                            hdr_record_value(
-                            config.latency_histogram,  // Histogram to record to
-                            (long)c->latency<=CONFIG_LATENCY_HISTOGRAM_MAX_VALUE ? (long)c->latency : CONFIG_LATENCY_HISTOGRAM_MAX_VALUE);  // Value to record
-                            hdr_record_value(
-                            config.current_sec_latency_histogram,  // Histogram to record to
-                            (long)c->latency<=CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE ? (long)c->latency : CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE);  // Value to record
-                        } else {
-                            hdr_record_value_atomic(
-                            config.latency_histogram,  // Histogram to record to
-                            (long)c->latency<=CONFIG_LATENCY_HISTOGRAM_MAX_VALUE ? (long)c->latency : CONFIG_LATENCY_HISTOGRAM_MAX_VALUE);  // Value to record
-                            hdr_record_value_atomic(
-                            config.current_sec_latency_histogram,  // Histogram to record to
-                            (long)c->latency<=CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE ? (long)c->latency : CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE);  // Value to record
-                        }
-                }
+            freeReplyObject(reply);
+            /* This is an OK for prefix commands such as auth and select.*/
+            if (c->prefix_pending > 0) {
+                c->prefix_pending--;
                 c->pending--;
-                if (c->pending == 0) {
-                    clientDone(c);
-                    break;
+                /* Discard prefix commands on first response.*/
+                if (c->prefixlen > 0) {
+                    size_t j;
+                    sdsrange(c->obuf, c->prefixlen, -1);
+                    /* We also need to fix the pointers to the strings
+                    * we need to randomize. */
+                    for (j = 0; j < c->randlen; j++)
+                        c->randptr[j] -= c->prefixlen;
+                    /* Fix the pointers to the slot hash tags */
+                    for (j = 0; j < c->staglen; j++)
+                        c->stagptr[j] -= c->prefixlen;
+                    c->prefixlen = 0;
                 }
-            } else {
+                continue;
+            }
+            int requests_finished = 0;
+            atomicGetIncr(config.requests_finished, requests_finished, 1);
+            if (requests_finished < config.requests){
+                    if (config.num_threads == 0) {
+                        hdr_record_value(
+                        config.latency_histogram,  // Histogram to record to
+                        (long)c->latency<=CONFIG_LATENCY_HISTOGRAM_MAX_VALUE ? (long)c->latency : CONFIG_LATENCY_HISTOGRAM_MAX_VALUE);  // Value to record
+                        hdr_record_value(
+                        config.current_sec_latency_histogram,  // Histogram to record to
+                        (long)c->latency<=CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE ? (long)c->latency : CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE);  // Value to record
+                    } else {
+                        hdr_record_value_atomic(
+                        config.latency_histogram,  // Histogram to record to
+                        (long)c->latency<=CONFIG_LATENCY_HISTOGRAM_MAX_VALUE ? (long)c->latency : CONFIG_LATENCY_HISTOGRAM_MAX_VALUE);  // Value to record
+                        hdr_record_value_atomic(
+                        config.current_sec_latency_histogram,  // Histogram to record to
+                        (long)c->latency<=CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE ? (long)c->latency : CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE);  // Value to record
+                    }
+            }
+            c->pending--;
+            if (c->pending == 0) {
+                clientDone(c, false);
                 break;
             }
+        } else {
+            break;
         }
     }
 }
@@ -617,8 +635,10 @@
     if (c->written == 0) {
         /* Enforce upper bound to number of requests. */
         int requests_issued = 0;
+        int requests_failed = 0;
         atomicGetIncr(config.requests_issued, requests_issued, config.pipeline);
-        if (requests_issued >= config.requests) {
+        atomicGet(config.requests_failed, requests_failed);
+        if (requests_issued - requests_failed >= config.requests) {
             return;
         }
 
@@ -630,7 +650,7 @@
         c->latency = -1;
     }
     const ssize_t buflen = sdslen(c->obuf);
-    const ssize_t writeLen = buflen-c->written;
+    const ssize_t writeLen = buflen - c->written;
     if (writeLen > 0) {
         void *ptr = c->obuf+c->written;
         while(1) {
@@ -639,7 +659,7 @@
             const ssize_t nwritten = cliWriteConn(c->context,ptr,writeLen);
             if (nwritten != writeLen) {
                 if (nwritten == -1 && errno != EAGAIN) {
-                    if (errno != EPIPE)
+                    if (errno != EPIPE && !config.quiet)
                         fprintf(stderr, "Error writing to the server: %s\n", strerror(errno));
                     freeClient(c);
                     return;
@@ -701,18 +721,29 @@
             port = node->port;
             c->cluster_node = node;
         }
-        c->context = redisConnectNonBlock(ip,port);
-    } else {
-        c->context = redisConnectUnixNonBlock(config.hostsocket);
     }
+
+    // (Attempt to) connect
+    int tries = 0;
+    do {
+        if (config.hostsocket == NULL || is_cluster_client) {
+            c->context = redisConnectNonBlock(ip,port);
+            if (c->context->err) {
+                fprintf(stderr,"%s:%d: %s\n",ip,port,c->context->errstr);
+            }
+        } else {
+            c->context = redisConnectUnixNonBlock(config.hostsocket);
+            if (c->context->err) {
+                fprintf(stderr,"%s: %s\n",config.hostsocket,c->context->errstr);
+            }
+        }
+        tries++;
+    } while(c->context->err && tries < config.connect_retries);
     if (c->context->err) {
-        fprintf(stderr,"Could not connect to Redis at ");
-        if (config.hostsocket == NULL || is_cluster_client)
-            fprintf(stderr,"%s:%d: %s\n",ip,port,c->context->errstr);
-        else
-            fprintf(stderr,"%s: %s\n",config.hostsocket,c->context->errstr);
+        fprintf(stderr, "Giving up connecting after %d tries.\n", tries);
         exit(1);
     }
+
     if (config.tls==1) {
         const char *err = NULL;
         if (cliSecureConnection(c->context, config.sslconfig, &err) == REDIS_ERR && err) {
@@ -845,8 +876,9 @@
         benchmarkThread *thread = config.threads[thread_id];
         el = thread->el;
     }
-    if (config.idlemode == 0)
+    if (config.idlemode == 0) {
         aeCreateFileEvent(el,c->context->fd,AE_WRITABLE,writeHandler,c);
+    }
     listAddNodeTail(config.clients,c);
     atomicIncr(config.liveclients, 1);
     atomicGet(config.slots_last_update, c->slots_last_update);
@@ -951,6 +983,7 @@
         printf("\n");
         printf("Summary:\n");
         printf("  throughput summary: %.2f requests per second\n", reqpersec);
+        printf("  failed requests: %d (%d requests successfully completed)\n", config.requests_failed, config.requests_finished);
         printf("  latency summary (msec):\n");
         printf("    %9s %9s %9s %9s %9s %9s\n", "avg", "min", "p50", "p95", "p99", "max");
         printf("    %9.3f %9.3f %9.3f %9.3f %9.3f %9.3f\n", avg, p0, p50, p95, p99, p100);
@@ -958,7 +991,7 @@
         printf("\"%s\",\"%.2f\",\"%.3f\",\"%.3f\",\"%.3f\",\"%.3f\",\"%.3f\",\"%.3f\"\n", config.title, reqpersec, avg, p0, p50, p95, p99, p100);
     } else {
         printf("%*s\r", config.last_printed_bytes, " "); // ensure there is a clean line
-        printf("%s: %.2f requests per second, p50=%.3f msec\n", config.title, reqpersec, p50);
+        printf("%s: %.2f requests per second, p50=%.3f msec (%d failed requests)\n", config.title, reqpersec, p50, config.requests_failed);
     }
 }
 
@@ -1541,6 +1574,10 @@
             config.sslconfig.ciphersuites = strdup(argv[++i]);
         #endif
         #endif
+        } else if(!strcmp(argv[i],"--retries")) {
+            if (lastarg) goto invalid;
+            int n_retries = atoi(argv[++i]);
+            config.connect_retries = n_retries;
         } else {
             /* Assume the user meant to provide an option when the arg starts
              * with a dash. We're done otherwise and should use the remainder
